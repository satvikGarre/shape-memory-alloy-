# -*- coding: utf-8 -*-
"""NiTiCu.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1819-roReec-yPM5Eh6uokWNCjqjiJfYi
"""

#Expanded Grid Search with Finer Resolution
import pandas as pd
import numpy as np
from sklearn.ensemble import StackingRegressor
from sklearn.linear_model import Ridge
from sklearn.ensemble import RandomForestRegressor, GradientBoostingRegressor
from sklearn.svm import SVR
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import StandardScaler
from sklearn.metrics import mean_absolute_error, r2_score

# --- 1. Load and prepare your dataset ---
df = pd.read_excel('Dataset_Final.xlsx')

# Feature engineering
df['Ni_Ti_ratio'] = df['Ni_content'] / df['Ti_content']
df['Ni_Cu_ratio'] = df['Ni_content'] / df['Cu_content']
df['Ti_Cu_ratio'] = df['Ti_content'] / df['Cu_content']
df['A_range'] = df['Af'] - df['As']
df['M_range'] = df['Ms'] - df['Mf']

features = ['Ni_content', 'Ti_content', 'Cu_content', 'Ni_Ti_ratio',
            'Ni_Cu_ratio', 'Ti_Cu_ratio', 'A_range', 'M_range']
X = df[features]
y = df['Hysteresis (Af - Ms)']

# Standardize features
scaler = StandardScaler()
X_scaled = scaler.fit_transform(X)

# Split data (for model training)
X_train, X_test, y_train, y_test = train_test_split(X_scaled, y, test_size=0.2, random_state=42)

# --- 2. Train the ensemble model ---
# (You can use your own model or this example)
rf = RandomForestRegressor(n_estimators=200, max_depth=None, min_samples_split=2, random_state=42)
gb = GradientBoostingRegressor(n_estimators=100, max_depth=3, learning_rate=0.1, random_state=42)
svr = SVR(C=10, epsilon=0.1, kernel='linear')

stack = StackingRegressor(
    estimators=[('rf', rf), ('gb', gb), ('svr', svr)],
    final_estimator=Ridge()
)
stack.fit(X_train, y_train)

# Evaluate model
y_pred = stack.predict(X_test)
print(f"Ensemble MAE: {mean_absolute_error(y_test, y_pred):.2f}")
print(f"Ensemble R²: {r2_score(y_test, y_pred):.3f}")

# --- 3. Generate new compositions with finer grid ---
new_compounds = []
for Ni in np.arange(25, 55, 1):  # 1% steps for Ni
    for Ti in np.arange(40, 55, 1):  # 1% steps for Ti
        Cu = 100 - Ni - Ti
        if Cu >= 5:  # Minimum 5% Cu
            new_compounds.append([Ni, Ti, Cu])

new_df = pd.DataFrame(new_compounds, columns=['Ni_content', 'Ti_content', 'Cu_content'])

# Add special region around Cu=10.4% (optional, to focus on research findings)
for Cu in np.arange(8, 13, 0.5):  # Focus on 8-13% Cu
    for Ni in np.arange(40, 50, 0.5):
        Ti = 100 - Ni - Cu
        if 40 <= Ti <= 55:
            new_compounds.append([Ni, Ti, Cu])
# Rebuild DataFrame and drop duplicates
new_df = pd.DataFrame(new_compounds, columns=['Ni_content', 'Ti_content', 'Cu_content'])
new_df = new_df.drop_duplicates()

# --- 4. Calculate features for new compounds ---
new_df['Ni_Ti_ratio'] = new_df['Ni_content'] / new_df['Ti_content']
new_df['Ni_Cu_ratio'] = new_df['Ni_content'] / new_df['Cu_content']
new_df['Ti_Cu_ratio'] = new_df['Ti_content'] / new_df['Cu_content']
new_df['A_range'] = df['A_range'].mean()
new_df['M_range'] = df['M_range'].mean()

# --- 5. Predict hysteresis for new compounds ---
X_new = scaler.transform(new_df[features])
new_df['Predicted_Hysteresis'] = stack.predict(X_new)

# --- 6. Find the best compounds ---
best_compound = new_df.loc[new_df['Predicted_Hysteresis'].idxmin()]
top_candidates = new_df.nsmallest(10, 'Predicted_Hysteresis')

print("\nBest compound predicted for low hysteresis:")
print(best_compound[['Ni_content', 'Ti_content', 'Cu_content', 'Predicted_Hysteresis']])
print("\nTop 10 low-hysteresis candidates:")
print(top_candidates[['Ni_content', 'Ti_content', 'Cu_content', 'Predicted_Hysteresis']])

import matplotlib.pyplot as plt
fig, axes = plt.subplots(3, 1, figsize=(6, 6))

# Plotting Ni content
axes[0].hist(df['Ni_content'], bins=20, color='skyblue', edgecolor='black')
axes[0].set_title('Distribution of Ni Content')
axes[0].set_xlabel('Ni Content (%)')
axes[0].set_ylabel('Frequency')

# Plotting Ti content
axes[1].hist(df['Ti_content'], bins=20, color='lightgreen', edgecolor='black')
axes[1].set_title('Distribution of Ti Content')
axes[1].set_xlabel('Ti Content (%)')
axes[1].set_ylabel('Frequency')

# Plotting Cu content
axes[2].hist(df['Cu_content'], bins=20, color='salmon', edgecolor='black')
axes[2].set_title('Distribution of Cu Content')
axes[2].set_xlabel('Cu Content (%)')
axes[2].set_ylabel('Frequency')

plt.tight_layout()
plt.show()

df.head()

import matplotlib.pyplot as plt
# 7. Generate Plots

# Predicted Hysteresis vs. Ni Content
plt.figure(figsize=(6, 6))
plt.scatter(new_df['Ni_content'], new_df['Predicted_Hysteresis'], alpha=0.5, s=10)
plt.title('Predicted Hysteresis vs. Ni Content')
plt.xlabel('Ni Content (%)')
plt.ylabel('Predicted Hysteresis')
plt.grid(True)
plt.show()

# Predicted Hysteresis vs. Ti Content
plt.figure(figsize=(6, 6))
plt.scatter(new_df['Ti_content'], new_df['Predicted_Hysteresis'], alpha=0.5, s=10)
plt.title('Predicted Hysteresis vs. Ti Content')
plt.xlabel('Ti Content (%)')
plt.ylabel('Predicted Hysteresis')
plt.grid(True)
plt.show()

# Predicted Hysteresis vs. Cu Content
plt.figure(figsize=(6, 6))
plt.scatter(new_df['Cu_content'], new_df['Predicted_Hysteresis'], alpha=0.5, s=10)
plt.title('Predicted Hysteresis vs. Cu Content')
plt.xlabel('Cu Content (%)')
plt.ylabel('Predicted Hysteresis')
plt.grid(True)
plt.show()

# Predicted Hysteresis vs. Ni/Ti Ratio
plt.figure(figsize=(6, 6))
plt.scatter(new_df['Ni_Ti_ratio'], new_df['Predicted_Hysteresis'], alpha=0.5, s=10)
plt.title('Predicted Hysteresis vs. Ni/Ti Ratio')
plt.xlabel('Ni/Ti Ratio')
plt.ylabel('Predicted Hysteresis')
plt.grid(True)
plt.show()

# Predicted Hysteresis vs. Ni/Cu Ratio
plt.figure(figsize=(6, 6))
plt.scatter(new_df['Ni_Cu_ratio'], new_df['Predicted_Hysteresis'], alpha=0.5, s=10)
plt.title('Predicted Hysteresis vs. Ni/Cu Ratio')
plt.xlabel('Ni/Cu Ratio')
plt.ylabel('Predicted Hysteresis')
plt.grid(True)
plt.show()

# Predicted Hysteresis vs. Ti/Cu Ratio
plt.figure(figsize=(6, 6))
plt.scatter(new_df['Ti_Cu_ratio'], new_df['Predicted_Hysteresis'], alpha=0.5, s=10)
plt.title('Predicted Hysteresis vs. Ti/Cu Ratio')
plt.xlabel('Ti/Cu Ratio')
plt.ylabel('Predicted Hysteresis')
plt.grid(True)
plt.show()

# Predicted Hysteresis Distribution
plt.figure(figsize=(6, 6))
plt.hist(new_df['Predicted_Hysteresis'], bins=50, color='purple', edgecolor='black')
plt.title('Distribution of Predicted Hysteresis')
plt.xlabel('Predicted Hysteresis')
plt.ylabel('Frequency')
plt.grid(True)
plt.show()

#heatmap

import matplotlib.pyplot as plt
import seaborn as sns

# Create a pivot table for the heatmap
# We'll pivot on Ni and Ti, using Cu implicitly as 100 - Ni - Ti
# Predicted_Hysteresis will be the value
heatmap_data = new_df.pivot_table(index='Ni_content', columns='Ti_content', values='Predicted_Hysteresis')

plt.figure(figsize=(6, 6))
sns.heatmap(heatmap_data, cmap='viridis', annot=False, cbar_kws={'label': 'Predicted Hysteresis'})
plt.title('Predicted Hysteresis Heatmap (Ni vs. Ti Content)')
plt.xlabel('Ti Content (%)')
plt.ylabel('Ni Content (%)')
plt.gca().invert_yaxis() # Invert y-axis to have lower Ni at the bottom
plt.show()

# Optional: Another heatmap considering Ni and Cu
heatmap_data_ni_cu = new_df.pivot_table(index='Ni_content', columns='Cu_content', values='Predicted_Hysteresis')

plt.figure(figsize=(6, 6))
sns.heatmap(heatmap_data_ni_cu, cmap='viridis', annot=False, cbar_kws={'label': 'Predicted Hysteresis'})
plt.title('Predicted Hysteresis Heatmap (Ni vs. Cu Content)')
plt.xlabel('Cu Content (%)')
plt.ylabel('Ni Content (%)')
plt.gca().invert_yaxis()
plt.show()

# Optional: Another heatmap considering Ti and Cu
heatmap_data_ti_cu = new_df.pivot_table(index='Ti_content', columns='Cu_content', values='Predicted_Hysteresis')

plt.figure(figsize=(6, 6))
sns.heatmap(heatmap_data_ti_cu, cmap='viridis', annot=False, cbar_kws={'label': 'Predicted Hysteresis'})
plt.title('Predicted Hysteresis Heatmap (Ti vs. Cu Content)')
plt.xlabel('Cu Content (%)')
plt.ylabel('Ti Content (%)')
plt.gca().invert_yaxis()
plt.show()

df.describe()

df.head()

import pandas as pd

data = pd.read_excel('Dataset_Final.xlsx')

data.head()

data.describe()

from sklearn.metrics import mean_absolute_error, r2_score, mean_squared_error, accuracy_score, precision_score
import numpy as np

# For regression tasks like this, accuracy and precision are not applicable.
# They are used for classification problems.

# Mean Squared Error (MSE)
mse = mean_squared_error(y_test, y_pred)
print(f"Random Forest MSE: {mse:.3f}")

# Root Mean Squared Error (RMSE)
rmse = np.sqrt(mse)
print(f"Random Forest RMSE: {rmse:.3f}")

# R-squared (already calculated, but included for completeness)
r2 = r2_score(y_test, y_pred)
print(f"Random Forest R²: {r2:.3f}")

# Mean Absolute Error (already calculated, but included for completeness)
mae = mean_absolute_error(y_test, y_pred)
print(f"Random Forest MAE: {mae:.2f}")

# Note: Accuracy and Precision cannot be computed for a regression model.
# If this were a classification problem (predicting discrete categories),
# you would calculate accuracy and precision like this:
# accuracy = accuracy_score(y_test, y_pred)
# precision = precision_score(y_test, y_pred, average='weighted') # or 'micro', 'macro', 'binary' depending on the problem